diff --git a/src/dbSta/include/db_sta/ToySizer.hh b/src/dbSta/include/db_sta/ToySizer.hh
new file mode 100644
index 0000000000..7d4dc95272
--- /dev/null
+++ b/src/dbSta/include/db_sta/ToySizer.hh
@@ -0,0 +1,63 @@
+// ECE 260C Lab 4
+// ToySizer - Small-scale ERC-compliance gate resizer
+// Created by Davit Markarian.
+//
+// Copyright (c) 2025 The Regents of the University of California
+// OpenROAD licenses apply. Do not redistribute. Do not edit this file.
+
+#pragma once
+
+#include <optional>
+#include <string>
+#include <vector>
+
+#include "sta/Sta.hh"
+#include "sta/Liberty.hh"
+#include "sta/StaState.hh"
+#include "db_sta/dbNetwork.hh"
+#include "utl/Logger.h"
+
+namespace sta {
+
+class ToySizer : public StaState
+{
+ public:
+  // The constructor takes the sta state, the database, and logger objects
+  ToySizer(Sta* sta, sta::dbNetwork* db_network, utl::Logger* logger);
+
+  // Provided for you, this function checks to see that a port is a signal (non-power/ground) output. 
+  bool isSignalOutput(sta::LibertyPort* port);
+
+  // Provided for you, this function returns the next strongest available master. 
+  std::optional<sta::LibertyCell*> getNextLargestCell(sta::LibertyCell* cell);
+  
+  // Take a buffer cell and upsize it to the next largest size.
+  bool upsizeInst(sta::Instance* inst);
+  
+  // Take maximum slew of the output port of an instance's master.
+  float getMaxSlew(sta::Instance* inst);
+
+  // Take maximum capacitance of the output port of an instance's master.
+  float getMaxCap(sta::Instance* inst);
+  
+  // Take slew of the output port of an instance.
+  float getSlew(sta::Instance* inst);
+
+  // Take capacitance of the output port of an instance.
+  float getCap(sta::Instance* inst);
+
+  // Return a vector with pointers to all undersized instances.
+  std::vector<sta::Instance*> findUndersizedInstances();
+  
+  // Run a resizing pass: identify all undersized instances and upsize them once.
+  void resize();
+
+ protected:
+  Sta* sta_;
+  sta::dbNetwork* db_network_;
+  utl::Logger* logger_;
+  sta::LibertyLibrary* default_library;
+  sta::Corner* default_corner;
+};
+
+}  // namespace sta
diff --git a/src/dbSta/src/CMakeLists.txt b/src/dbSta/src/CMakeLists.txt
index 633e7f146b..c8f3ba975d 100644
--- a/src/dbSta/src/CMakeLists.txt
+++ b/src/dbSta/src/CMakeLists.txt
@@ -9,6 +9,7 @@ add_library(dbSta_lib
   dbSdcNetwork.cc
   dbReadVerilog.cc
   SpefWriter.cc
+  ToySizer.cc
 )
 
 target_include_directories(dbSta_lib
diff --git a/src/dbSta/src/ToySizer.cc b/src/dbSta/src/ToySizer.cc
new file mode 100644
index 0000000000..6d0c9f594d
--- /dev/null
+++ b/src/dbSta/src/ToySizer.cc
@@ -0,0 +1,275 @@
+#include "db_sta/ToySizer.hh"
+
+#include <cstddef>
+
+#include "sta/Corner.hh"
+#include "sta/DelayFloat.hh"
+#include "sta/EquivCells.hh"
+#include "sta/Graph.hh"
+#include "sta/Liberty.hh"
+#include "sta/LibertyClass.hh"
+#include "sta/MinMax.hh"
+#include "sta/NetworkClass.hh"
+#include "sta/PortDirection.hh"
+#include "utl/Logger.h"
+#include "utl/exception.h"
+
+sta::ToySizer::ToySizer(Sta* sta,
+                        sta::dbNetwork* db_network,
+                        utl::Logger* logger)
+    : StaState(sta), sta_(sta), db_network_(db_network), logger_(logger)
+{
+  // Do not edit.
+
+  default_library = network()->defaultLibertyLibrary();
+  if (default_library == nullptr) {
+    logger_->error(utl::STA, 6400, "Error: no library loaded");
+  }
+
+  default_corner = corners()->findCorner(0);
+  if (default_corner == nullptr) {
+    logger_->error(utl::STA, 6401, "Error: no corners found.");
+  }
+
+  sta_->ensureLinked();
+  sta_->ensureGraph();
+}
+
+// Provided for you. Do not edit.
+bool sta::ToySizer::isSignalOutput(sta::LibertyPort* port)
+{
+  return port->direction()->isOutput()
+         && !db_network_->staToDb(port)->getSigType().isSupply();
+}
+
+// Provided for you. Do not edit.
+std::optional<sta::LibertyCell*> sta::ToySizer::getNextLargestCell(
+    sta::LibertyCell* cell)
+{
+  LibertyLibrarySeq libraries;
+  libraries.push_back(default_library);
+
+  EquivCells eq(&libraries, nullptr);
+  LibertyCellSeq* equivs = eq.equivs(cell);
+
+  // This cell has no equivalents
+  if (equivs == nullptr) {
+    return {};
+  }
+
+  // We will loop through all equivalent (in connectivity and functionality)
+  // cells and find the cell with the next biggest area Area here is our proxy
+  // for drive strength
+  LibertyCell* next_best_cell = nullptr;
+  float min_area = INF;
+
+  for (auto equiv : *equivs) {
+    float equiv_area = equiv->area();
+
+    if (equiv_area > cell->area() && equiv_area < min_area) {
+      next_best_cell = equiv;
+      min_area = equiv_area;
+    }
+  }
+
+  if (next_best_cell != nullptr) {
+    return next_best_cell;
+  }
+  
+  return {};
+}
+
+bool sta::ToySizer::upsizeInst(sta::Instance* inst)
+{
+  /*
+    Cell upsizing can be done in two steps:
+    1. Find the next strongest cell.
+    2. Replace that cell in the database.
+
+    You also have to handle the case in which no larger cell is available.
+    If no larger cell is available, return false.
+    If one is available and the replacement is done, return true.
+  */
+
+  // TODO: First, retrieve the LibertyCell from the instance using
+  // db_network_->libertyCell(instance) This is equivalent to calling getMaster
+  // in OpenDB.
+  sta::LibertyCell* cell = db_network_->libertyCell(inst);
+
+  // TODO: Now, get a stronger cell using the getNextLargestCell function
+  // defined above. getNextLargestCell will return a LibertyCell that's wrapped
+  // with an optional.
+  std::optional<sta::LibertyCell*> stronger_cell = ...;
+
+  // TODO: Determine if a stronger cell is unavailable by seeing if the
+  // std::optional can't be unwrapped. See here:
+  // https://en.cppreference.com/w/cpp/utility/optional/
+
+  // TODO: Perform the cell replacement, replacing the instance's master with
+  // the stronger equivalent found above. Key function:
+  // db_network_->replaceCell(instance, cell)
+  // https://github.com/The-OpenROAD-Project/OpenSTA/blob/65c2943191b8c59a065fcbb28519917a944eadef/include/sta/Network.hh#L510
+  // This is equivalent to calling swapMaster in OpenDB.
+  // Remember that you have to unwrap the std::optional. You may also need to
+  // convert it to a generic cell by callling db_network_->cell().
+
+  db_network_->replaceCell(...);
+  return true;
+}
+
+float sta::ToySizer::getMaxSlew(sta::Instance* inst)
+{
+  /*
+    The following functions follow a similar pattern.
+    1. We iterate through all pins and check if they are output pins.
+    2. We retrieve some information associated with the pin (like slack)
+    3. If that information is not attached to the pin (i.e. the library doesn't
+    provide it), then we use some backups.
+  */
+
+  InstancePinIterator* iter = db_network_->pinIterator(inst);
+  float limit;
+  bool exists;
+
+  // Now, we iterate through all pins.
+  while (iter->hasNext()) {
+    sta::Pin* pin = iter->next();
+    // TODO: use db_network_->libertyPort to get the master's pin and its
+    // associated information. This is equivalent to getting the MTerm for an
+    // ITerm in OpenDB.
+    sta::LibertyPort* port = ...;
+
+    // TODO: use isSignalOutput to see if this is an output port. Otherwise,
+    // continue to the next pin. If it is, then call
+    // port->slewLimit(MinMax::max(), limit, exists) Finally, if the slew limit
+    // exists, then return it. Otherwise, continue the loop.
+
+    if(isSignalOutput(...)) {
+      ...
+    }
+  }
+
+  // Handled for you: if the cell pin has no max slew declared,
+  // find the library's default. If that doesn't exist, return Infinity.
+  default_library->defaultMaxSlew(limit, exists);
+  return exists ? limit : INF;
+}
+
+float sta::ToySizer::getMaxCap(sta::Instance* inst)
+{
+  InstancePinIterator* iter = db_network_->pinIterator(inst);
+  float limit;
+  bool exists;
+
+  while (iter->hasNext()) {
+    sta::Pin* pin = iter->next();
+
+    // Similar to getMaxSlew.
+    sta::LibertyPort* port = ...;
+
+    // TODO: use isSignalOutput to see if this is an output port. Otherwise,
+    // continue to the next pin. If it is, then call
+    // port->capacitanceLimit(MinMax::max(), limit, exists) Finally, if the
+    // capacitance limit exists, then return it. Otherwise, continue the loop.
+  }
+
+  // Handled for you: if the cell has no max capacitance declared,
+  // find the library's default. If that doesn't exist, return Infinity.
+  default_library->defaultMaxCapacitance(limit, exists);
+  return exists ? limit : INF;
+}
+
+
+float sta::ToySizer::getSlew(sta::Instance* inst)
+{
+  InstancePinIterator* iter = db_network_->pinIterator(inst);
+
+  while (iter->hasNext()) {
+    sta::Pin* pin = iter->next();
+
+    if (isSignalOutput(db_network_->libertyPort(pin))) {
+      // To retrieve slew, we need to retrieve vertices in the timing graph
+      // Recall from the lecture on STA that bidirectional pins have two vertices.
+      Vertex *vertex, *vertex_bidirect;
+      sta_->ensureGraph()->pinVertices(pin, vertex, vertex_bidirect);
+
+      // TODO: Check if vertex is a null pointer (nullptr)
+      // If not, then return its worst-case slew using sta::delayAsFloat(sta_->vertexSlew(... , MinMax::max()));
+      // If it is a null pointer, then check vertex_bidirect in the same way,
+      // returning its worst-case slew if it is not a null pointer.
+      // If they are both null, then allow the loop to continue. 
+
+      if(vertex == ...) {
+        return ...
+      } else if (...) {
+        ...
+      }
+
+    }
+  }
+
+  return -INF;
+}
+
+float sta::ToySizer::getCap(sta::Instance* inst)
+{
+  InstancePinIterator* iter = db_network_->pinIterator(inst);
+
+  while (iter->hasNext()) {
+    sta::Pin* pin = iter->next();
+    sta::LibertyPort* port = db_network_->libertyPort(pin);
+    sta::Net* net = db_network_->net(pin);
+
+    // TODO: Check that the LibertyPort is not a null pointer and is an output.
+    // If so, Retrieve its capacitance for the default corner (see ToySizer.hh).
+    // Finally, return the sum of pin and wire capacitances.
+    // Otherwise, the loop should continue.
+
+    if (... && ...) {
+      float pin_cap, wire_cap;
+      
+      // Useful function:  sta_->connectedCap(net, corner, sta::MinMax::max(), pin_cap, wire_cap);
+
+    }
+  }
+
+  return -INF;
+}
+
+std::vector<sta::Instance*> sta::ToySizer::findUndersizedInstances()
+{
+  std::vector<sta::Instance*> undersized_insts;
+
+  LeafInstanceIterator* insts = db_network_->leafInstanceIterator();
+
+  while (insts->hasNext()) {
+    sta::Instance* inst = insts->next();
+
+    // TODO: Call the functions we just defined above to get slew/capacitance information.
+    // Then, compare the values to see if *either* max slew or max cap are violated.
+    // If so, use the push_back method to add the inst to the undersized_insts vector.
+    // Otherwise, ignore the instance.
+
+
+  }
+
+  return undersized_insts;
+}
+
+void sta::ToySizer::resize()
+{
+
+  auto undersized = findUndersizedInstances();
+  int successfulCount = 0;
+
+  for (sta::Instance* inst : undersized) {
+    // TOOD: call your upsize function and, if it is successful, increment successfulCount.
+  }
+
+  logger_->info(utl::STA,
+                6403,
+                "Toy Resizer: Upsized {} out of {} under-sized cells.",
+                successfulCount,
+                undersized.size());
+  sta_->ensureGraph();
+}
\ No newline at end of file
diff --git a/src/dbSta/src/dbSta.i b/src/dbSta/src/dbSta.i
index 5340200fc1..a17a7a6f91 100644
--- a/src/dbSta/src/dbSta.i
+++ b/src/dbSta/src/dbSta.i
@@ -10,6 +10,7 @@
 #include "ord/OpenRoad.hh"
 #include "sta/Property.hh"
 #include "sta/VerilogWriter.hh"
+#include "db_sta/ToySizer.hh"
 
 namespace ord {
 // Defined in OpenRoad.i
@@ -213,4 +214,16 @@ replace_hier_module_cmd(odb::dbModInst* mod_inst, odb::dbModule* module)
   (void) db_network->replaceHierModule(mod_inst, module);
 }
 
+void toy_resize_cmd() {
+  ord::OpenRoad *openroad = ord::getOpenRoad();
+  sta::ToySizer sizer(openroad->getSta(), openroad->getDbNetwork(), openroad->getLogger());
+  sizer.resize();
+}
+
+int toy_count_undersized_cmd() {
+  ord::OpenRoad *openroad = ord::getOpenRoad();
+  sta::ToySizer sizer(openroad->getSta(), openroad->getDbNetwork(), openroad->getLogger());
+  return sizer.findUndersizedInstances().size();
+}
+
 %} // inline
diff --git a/src/dbSta/src/dbSta.tcl b/src/dbSta/src/dbSta.tcl
index 38e7aa8e17..d2e6b7fc02 100644
--- a/src/dbSta/src/dbSta.tcl
+++ b/src/dbSta/src/dbSta.tcl
@@ -140,5 +140,19 @@ proc get_hier_module { arg } {
 }
 interp alias {} get_design {} get_hier_module
 
+define_cmd_args "toy_resize" {}
+
+proc toy_resize {} {
+  ::sta::toy_resize_cmd
+}
+
+define_cmd_args "toy_count_undersized" {}
+
+proc toy_count_undersized {} {
+  set count [::sta::toy_count_undersized_cmd]
+  puts "$count undersized cells found."
+  return $count
+}
+
 # namespace
 }
